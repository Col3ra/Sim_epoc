<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Simulador EPOC Procedural - Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Segoe UI', sans-serif; color: white; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Estilo Videojuego */
        #ui-layer {
            position: absolute;
            top: 30px;
            left: 30px;
            width: 280px;
            background: rgba(10, 15, 20, 0.85);
            border-left: 4px solid #00ccff;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 204, 255, 0.15);
            user-select: none;
        }
        h1 { margin: 0 0 15px 0; font-size: 1.1rem; color: #00ccff; text-transform: uppercase; letter-spacing: 1px; font-weight: 800; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.9rem; color: #aaa; }
        .value { color: white; font-weight: bold; font-family: monospace; font-size: 1rem; }
        .status-box {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #333;
            text-align: center;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.3s;
        }
        
        .control-group { margin-top: 25px; border-top: 1px solid #333; padding-top: 15px; }
        label { display: block; font-size: 0.75rem; color: #00ccff; margin-bottom: 5px; text-transform: uppercase; }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: #00ccff; }
        
        /* Decoración UI */
        .corner { position: absolute; width: 10px; height: 10px; border: 2px solid #00ccff; }
        .tr { top: -2px; right: -2px; border-bottom: none; border-left: none; }
        .bl { bottom: -2px; left: -2px; border-top: none; border-right: none; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div class="corner tr"></div><div class="corner bl"></div>
        <h1>Monitor Pulmonar</h1>
        
        <div class="stat-row"><span>Volumen:</span> <span id="vol-text" class="value">0.00 L</span></div>
        <div class="stat-row"><span>Flujo:</span> <span id="flow-text" class="value">0.00 L/s</span></div>
        <div class="stat-row"><span>SatO2 (Sim):</span> <span id="sat-text" class="value">98%</span></div>
        
        <div id="status-box" class="status-box">INICIANDO...</div>

        <div class="control-group">
            <label>Severidad Obstrucción (EPOC)</label>
            <input type="range" id="severity" min="0" max="1" step="0.1" value="0.8">
            
            <label style="margin-top:10px">Frecuencia Respiratoria</label>
            <input type="range" id="speed" min="0.2" max="2.0" step="0.1" value="1.0">
        </div>
        <div style="margin-top:15px; font-size: 0.7rem; color: #555;">
            Renderizado Procedural • No external assets
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 1. SETUP BÁSICO ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020205, 0.02);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 2. GENERADOR DE TEXTURA PROCEDURAL (Para simular tejido) ---
        function createOrganicTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; 
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Fondo oscuro
            ctx.fillStyle = '#200000';
            ctx.fillRect(0, 0, 512, 512);
            
            // Ruido para alveolos
            for(let i=0; i<5000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 2 + 1;
                ctx.fillStyle = `rgba(255, 100, 100, ${Math.random() * 0.1})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI*2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        const lungTexture = createOrganicTexture();

        // --- 3. CONSTRUCCIÓN PROCEDURAL DE PULMONES ---
        const lungsGroup = new THREE.Group();
        scene.add(lungsGroup);

        // Material "Holograma Orgánico"
        const membraneMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xff3333,        // Color base rojo sangre
            emissive: 0x550000,     // Brillo interno oscuro
            roughness: 0.6,
            metalness: 0.1,
            transmission: 0.4,      // Translucidez (importante para ver el interior)
            thickness: 1.0,
            transparent: true,
            opacity: 0.8,
            map: lungTexture,       // Nuestra textura generada
            side: THREE.DoubleSide
        });

        // Función para crear un lóbulo (Esfera deformada)
        function createLobe(scaleVec, posVec, rotationZ) {
            const geo = new THREE.SphereGeometry(1, 64, 64);
            const mesh = new THREE.Mesh(geo, membraneMaterial);
            mesh.scale.copy(scaleVec);
            mesh.position.copy(posVec);
            mesh.rotation.z = rotationZ;
            mesh.castShadow = true;
            return mesh;
        }

        // --- PULMÓN DERECHO (3 Lóbulos simulados) ---
        const rightLung = new THREE.Group();
        // Lóbulo superior/medio fusionados
        rightLung.add(createLobe(new THREE.Vector3(1.2, 2.0, 1.2), new THREE.Vector3(0, 0.5, 0), -0.1)); 
        // Base más ancha
        rightLung.add(createLobe(new THREE.Vector3(1.3, 1.5, 1.3), new THREE.Vector3(0.2, -1.0, 0.1), 0)); 
        rightLung.position.x = 1.4;
        lungsGroup.add(rightLung);

        // --- PULMÓN IZQUIERDO (2 Lóbulos + Hueco cardíaco) ---
        const leftLung = new THREE.Group();
        // Lóbulo superior
        leftLung.add(createLobe(new THREE.Vector3(1.15, 1.9, 1.15), new THREE.Vector3(0, 0.6, 0), 0.1));
        // Lóbulo inferior (ligeramente desplazado por el corazón)
        leftLung.add(createLobe(new THREE.Vector3(1.2, 1.4, 1.2), new THREE.Vector3(-0.1, -1.0, 0), 0));
        leftLung.position.x = -1.4;
        lungsGroup.add(leftLung);

        // --- TRÁQUEA ---
        const tracheaGeo = new THREE.CylinderGeometry(0.4, 0.4, 2.5, 16);
        const trachea = new THREE.Mesh(tracheaGeo, membraneMaterial);
        trachea.position.y = 3.0;
        lungsGroup.add(trachea);

        // --- 4. ÁRBOL BRONQUIAL FRACTAL (GENERATIVO) ---
        // Esto crea las "venas" brillantes internas
        const bronchiMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
        
        function createFractalBranch(startPoint, direction, length, depth) {
            if (depth === 0) return null;

            const endPoint = new THREE.Vector3().copy(startPoint).add(direction.clone().multiplyScalar(length));
            const points = [startPoint, endPoint];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, bronchiMaterial);
            
            const branchGroup = new THREE.Group();
            branchGroup.add(line);

            // Ramificación
            const nextLength = length * 0.75;
            
            // Rama A
            const dirA = direction.clone().applyAxisAngle(new THREE.Vector3(0, 0, 1), 0.5).applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.random());
            const branchA = createFractalBranch(endPoint, dirA, nextLength, depth - 1);
            if(branchA) branchGroup.add(branchA);

            // Rama B
            const dirB = direction.clone().applyAxisAngle(new THREE.Vector3(0, 0, 1), -0.5).applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.random());
            const branchB = createFractalBranch(endPoint, dirB, nextLength, depth - 1);
            if(branchB) branchGroup.add(branchB);

            return branchGroup;
        }

        // Generar árbol derecho e izquierdo
        const treeRight = createFractalBranch(new THREE.Vector3(0, 2, 0), new THREE.Vector3(0.5, -1, 0).normalize(), 1.2, 5);
        if(treeRight) { treeRight.position.x = 0; lungsGroup.add(treeRight); }
        
        const treeLeft = createFractalBranch(new THREE.Vector3(0, 2, 0), new THREE.Vector3(-0.5, -1, 0).normalize(), 1.2, 5);
        if(treeLeft) { treeLeft.position.x = 0; lungsGroup.add(treeLeft); }


        // --- 5. GRÁFICO FLOTANTE 3D (Holograma lateral) ---
        const graphGroup = new THREE.Group();
        graphGroup.position.set(5, 0, 0);
        graphGroup.rotation.y = -0.3;
        scene.add(graphGroup);

        // Marco del gráfico
        const gridHelper = new THREE.GridHelper(6, 10, 0x005588, 0x002244);
        gridHelper.rotation.x = Math.PI / 2;
        gridHelper.position.set(1.5, 1.5, 0);
        graphGroup.add(gridHelper);

        const curvePoints = new Array(100).fill(new THREE.Vector3(0,0,0));
        const curveGeo = new THREE.BufferGeometry().setFromPoints(curvePoints);
        const curveMat = new THREE.LineBasicMaterial({ color: 0xffcc00, linewidth: 2 });
        const curveLine = new THREE.Line(curveGeo, curveMat);
        graphGroup.add(curveLine);

        const cursorMesh = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({color: 0xffffff}));
        graphGroup.add(cursorMesh);


        // --- 6. ILUMINACIÓN Y POST-PROCESO ---
        const ambientLight = new THREE.AmbientLight(0x111111);
        scene.add(ambientLight);
        
        const spotLight = new THREE.SpotLight(0x00ccff, 100);
        spotLight.position.set(5, 10, 10);
        spotLight.angle = 0.5;
        spotLight.penumbra = 1;
        scene.add(spotLight);
        
        const redRimLight = new THREE.PointLight(0xff0000, 10, 20);
        redRimLight.position.set(-5, 0, -5);
        scene.add(redRimLight);

        // Bloom
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 0.8;
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);


        // --- 7. FÍSICA Y ANIMACIÓN ---
        let time = 0;
        let cyclePosition = 0; // 0 a 1
        
        const uiVol = document.getElementById('vol-text');
        const uiFlow = document.getElementById('flow-text');
        const uiStatus = document.getElementById('status-box');
        const uiSeverity = document.getElementById('severity');
        const uiSpeed = document.getElementById('speed');

        const maxVol = 4.0;
        const trailPositions = [];

        function updatePhysiology(dt) {
            const severity = parseFloat(uiSeverity.value); // 0 (Sano) a 1 (EPOC Severo)
            const speedMult = parseFloat(uiSpeed.value);
            
            // Ajustar duración ciclo según obstrucción (EPOC respira más rápido superficialmente o lento forzado)
            const cycleDuration = 5 / speedMult; 
            
            cyclePosition += dt / cycleDuration;
            if (cyclePosition > 1) {
                cyclePosition = 0;
                // Reset trail visual
            }

            // Fases
            const inspRatio = 0.35; // Inspiración corta
            let vol = 0;
            let flow = 0;

            if (cyclePosition < inspRatio) {
                // INSPIRACIÓN
                uiStatus.innerText = "INSPIRACIÓN";
                uiStatus.style.color = "#00ccff";
                uiStatus.style.borderColor = "#00ccff";
                
                const t = cyclePosition / inspRatio;
                vol = Math.sin(t * Math.PI / 2); // 0 a 1 suave
                flow = Math.cos(t * Math.PI / 2) * 5; // Flujo entrada
            } else {
                // ESPIRACIÓN (Aquí ocurre el EPOC)
                uiStatus.innerText = severity > 0.5 ? "ESPIRACIÓN OBSTRUIDA" : "ESPIRACIÓN";
                uiStatus.style.color = "#ff3366";
                uiStatus.style.borderColor = "#ff3366";

                const t = (cyclePosition - inspRatio) / (1 - inspRatio);
                
                // Fórmula de colapso EPOC
                // Si severity es alto, el volumen baja muy lento (Atrapamiento)
                const collapseFactor = 3 + (severity * 5); 
                vol = Math.pow(1 - t, severity > 0.3 ? 1.5 : 1); // Volumen cae
                
                // Atrapamiento aéreo (Nunca llega a 0 absoluto si hay severidad)
                vol = vol * (1 - (severity * 0.3)) + (severity * 0.3);

                // Flujo: CAE BRUSCAMENTE (Concavidad)
                if (t < 0.15) {
                    // Pico Flujo (PEF)
                    flow = -6 * Math.sin(t * Math.PI * 3); 
                } else {
                    // Caída cóncava
                    const obst = 1 - Math.pow(t, 1/(1+severity*2)); 
                    flow = -obst * 4;
                }
            }

            // --- ACTUALIZAR VISUALES ---
            
            // 1. Expansión Pulmones
            // En EPOC el pulmón está hiperinsuflado (siempre un poco expandido)
            const baseScale = 1 + (severity * 0.2); 
            const expansion = baseScale + (vol * 0.3);
            
            rightLung.scale.setScalar(expansion);
            leftLung.scale.setScalar(expansion);
            
            // Color cambia con oxigenación simulada
            const oxColor = new THREE.Color(0x440000).lerp(new THREE.Color(0xff3333), vol);
            membraneMaterial.color = oxColor;

            // 2. Expansión Árbol Bronquial (Menor que los pulmones)
            const treeExp = 1 + (vol * 0.1);
            if(treeRight) treeRight.scale.setScalar(treeExp);
            if(treeLeft) treeLeft.scale.setScalar(treeExp);

            // 3. Gráfico
            uiVol.innerText = (vol * maxVol).toFixed(2) + " L";
            uiFlow.innerText = flow.toFixed(2) + " L/s";
            
            const graphX = vol * 3;
            const graphY = flow * 0.5 + 1.5; // Offset Y
            cursorMesh.position.set(graphX, graphY, 0);
            
            // Rastro del loop actual
            // (Simplificado para performance)
            
        }

        // --- LOOP ---
        const clock = new THREE.Clock();
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const t = clock.getElapsedTime();

            updatePhysiology(dt);

            // Movimiento "Vivo" (Flotación)
            lungsGroup.position.y = Math.sin(t * 0.5) * 0.1;
            lungsGroup.rotation.y = Math.sin(t * 0.2) * 0.05;

            controls.update();
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
